//
//  Eric Pratt, Aditya Khandkar
//

typedef int bool;
const bool true = 1;
const bool false = 0;

const int DELAY = 10000;
const int DOWNSTREAM = 0;
// const int UPSTREAM = 1;
const int GATE1 = 1;
const int GATE2 = 2;

int id_up = 0;
int id_down = 0;

// return a unique ID based on direction of travel.
atomic int getId(int dir){
  if(dir == DOWNSTREAM) return ++id_down;
  return ++id_up;
}

atomic void print(string msg){
  cout << msg << endl;
}

void delay(){
  int i, delay;
  delay = random(DELAY);
  while(i++ < delay);
}


//               Gate 1           Gate 2
//
//                --                --
//DOWNSTREAM -->  ||                ||
//################||                ||
//                ||     LOCK       ||
//                ||                ||    <-- UPSTREAM
//       WATER    ||################||##################
//                ||                ||
//                ||     WATER      ||     WATER
//--------------------------------------------------------

monitor ControlTower {
  condition lock_empty;
  condition lock_full;
  condition lock_occupied;

  int q_upstream[64];
  int q_downstream[64];

  //string msg;
  //string prefix;

  void fill(){
    delay();
    waitc(lock_empty);
  }
  
  void drain(){
    delay();
    // signalc(lock_empty);
  }
 
  void arrive(int ship, int gate){							

    /*
    if(gate == GATE1) // downstream ships approach gate 1
      stringCopy(prefix, "D");
    else
      stringCopy(prefix, "U");

    sprintf(msg, "%s_%d is approaching gate %d",prefix,ship,gate);
    print(msg);
    */
    
  }

  int finish;

  init {
    finish = 0;
  }
}

void downstream(){
  int i, id;
  for(i = 0;i < 5;i++){
    id = getId(DOWNSTREAM);
    arrive(id, GATE1);
  }
}

void upstream(){
  int i, id;
  for(i = 0;i < 5;i++){
    id = getId(UPSTREAM);
    arrive(id, GATE2);
  }
}

// 
void waterlevel(int pid){
  fill();

  drain();
}

main(){

  cobegin{
    waterlevel(); // 0 -> water level process.
    upstream();// upstream(3), upstream(5), upstream(7), upstream(9), upstream(11), upstream(13), upstream(15), 
    downstream(); 
    //, downstream(4), downstream(6), downstream(8), downstream(10), downstream(12), downstream(14), downstream(16)
  }
}