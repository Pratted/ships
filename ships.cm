//
//  Eric Pratt
//

typedef int bool;
const bool true = 1;
const bool false = 0;

const int DELAY = 10000;
const int DOWNSTREAM = 0;
const int UPSTREAM = 1;
const int GATE1 = 1;
const int GATE2 = 2;

int id_up = -1;
int id_down = -1;

// return a unique ID based on direction of travel.
atomic int getid(int dir){
  if(dir == UPSTREAM) return ++id_up;
  if(dir == DOWNSTREAM) return ++id_down;

  // error
  return -1;
}
atomic void print(string msg){
  cout << msg << endl;
}

void pause(){
  int i, delay;
  delay = random(DELAY);
  while(i++ < delay);
}


//               Gate 1           Gate 2
//
//                --                --
//DOWNSTREAM -->  ||                ||
//################||                ||
//                ||     LOCK       ||
//                ||                ||    <-- UPSTREAM
//       WATER    ||################||##################
//                ||                ||
//                ||     WATER      ||     WATER
//--------------------------------------------------------

monitor ControlTower {
  condition lock_drained;
  condition lock_full;

  condition fill_lock;
  condition drain_lock;

  condition gate1_ready;
  condition gate2_ready;

  int q_upstream[64];
  int q_downstream[64];

  int len_qu;
  int len_qd;

  bool drained;
  bool occupied;

  //string msg;
  //string prefix;

  void fill(){
    wait(fill_lock); // fill the lock when requested

    // let the water flow into the lock and fill it
    drained = false;

    // let other processes aware the lock is full.
    signal(lock_full);
  }
  
  void drain(){
    waitc(drain_lock);

    drained = true;

    signal(lock_drained);
  }
 
  void arrive(int ship, int gate){

    // not occupied and empty queue -> this ship can enter
    if(occupied == false && len_qd + len_qu == 0){
      occupied = true;
    }

    // 
    else {
      if(gate == GATE1){
        q_downstream[len_qd] = ship;
        len_qd++;

        waitc(gate1_ready);
      }
      else if(gate == GATE2){
        q_upstream[len_qu] = ship;
        len_qd++;

        waitc(gate2_ready);
      }
    }

    signal(ship_ready);


    /*
    if(gate == GATE1) // downstream ships approach gate 1
      stringCopy(prefix, "D");
    else
      stringCopy(prefix, "U");

    sprintf(msg, "%s_%d is approaching gate %d",prefix,ship,gate);
    print(msg);
    */
  }

  void enter(int gate){

    // a ship is going to enter gate1
    if(gate == GATE1){

      // fill the lock so the ship can enter it.
      // (this only happens when there are no ships in the other direction)
      if(drained){
        signal(fill_lock);
        wait(lock_full);        
      }

      // now the water level is full. open the gate and let the ship enter.
      signal(gate2_ready);
      
      // send this bitch DOWNNNNN
      signal(drain_lock);

      // lock has finished draining. open gate2 and let this guy out.
      wait(lock_drained);

      // let other ships know the lock is ready to use.
      signal(gate1_ready);
    }
    if(gate == GATE2){

      if(drained == false){
        signal(drain_lock);
        wait(lock_drained);
      }

      // now the water level is full. open the gate and let the ship enter.
      signal(gate1_ready);

      signal(fill_lock);

      wait(lock_full);

      signal(gate2_ready);
    }
  }


  init {
    drained = true;
    occupied = false;
  }
}

void downstream(int pid){
  int i, id;
  for(i=0;i<5;i++){
    id = getid(DOWNSTREAM);
    arrive(id, GATE1);
  }
}

void upstream(int pid){
  int i, id;
  for(i=0;i<5;i++){
    id = getid(UPSTREAM);
    arrive(id, GATE2);
  }
}

// assume the water level starts in the 'drained' state like the diagram
// this process doesn't give a fuck whether or not theres aship in the lock, it just changes the water level
void waterlevel(int pid){
  while(1){
    fill();
    drain();
  }
}

main(){

  cobegin{
    waterlevel(0); // 0 -> water level process.
    upstream(1);// upstream(3), upstream(5), upstream(7), upstream(9), upstream(11), upstream(13), upstream(15), 
    downstream(2); 
    //, downstream(4), downstream(6), downstream(8), downstream(10), downstream(12), downstream(14), downstream(16)
  }
}